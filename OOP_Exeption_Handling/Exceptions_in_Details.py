# Exceptions in Details
# Exception Hierarchy
# Исключения являются объектами классов исключений. Все классы исключений в Python являются подклассами класса BaseException. Все встроенные классы исключений наследуются от класса Exception, который является подклассом класса BaseException. Вы можете увидеть полный список иерархии исключений, но мы убрали основные и часто используемые классы исключений:
# Иногда у вас могут быть задачи, в которых может возникнуть несколько разных ошибок в зависимости от того, как работает программа.
#
# Давайте рассмотрим программу, которая делит два заданных пользователем числа бесконечное число раз. Здесь могут быть некоторые ошибки. Первая ошибка — недопустимое значение, которое нельзя преобразовать в число. Вторая ошибка - второе число равно нулю.
#
# Есть несколько способов решения проблемы множественных ошибок. Первый способ — просто использовать блок try-except без указания ошибки. В этом случае будет отображаться только одна ошибка, и мы не будем знать, почему возникла ошибка и что нужно исправить. Это плохая практика, если ваша программа может вызывать различные ошибки:

while True:
	try:
		first = int(input())
		second = int(input())
		print(first / second)
	except:
		print("Error")

# Второй способ — когда мы можем наследоваться от базового класса Exception, но это тоже плохая практика, потому что вы не обрабатываете отдельные ошибки отдельно, и, возможно, есть другие непредвиденные ошибки, которые вы не хотите обрабатывать:
while True:
	try:
		first = int(input())
		second = int(input())
		print(first / second)
	except Exception as error:
		print("Error: ", error)

# Разница между первым и вторым примерами заключается в том, что во втором вы можете получить доступ к атрибутам объекта Exception.
# Лучший способ — использовать несколько блоков исключений и указать разные классы для обработки исключений. При этом каждый блок exclude может иметь свой обработчик:
while True:
	try:
		first = int(input())
		second = int(input())
		print(first / second)
	except TypeError as e:
		print("Both values must be numbers ", e)
	except ZeroDivisionError as e:
		print("You are trying to divide by zero ", e)
	except KeyboardInterrupt as e:
		print("The program is completed ", e)

# В этом примере мы добавили исключение KeyboardInterrupt, которое будет вызываться, когда человек захочет остановить программу комбинацией клавиш Ctrl (Command) + C.
# Помните, что если у нас есть несколько ошибок, очень важно соблюдать порядок указанных ошибок, потому что порядок будет идти от первого исключения к последнему. Более важные и частые ошибки — указаны ранее.

# Re-Raise Exception
# Используйте ключевое слово повышения, чтобы повторно вызвать ошибку. Повторное возбуждение исключения необходимо, когда мы хотим, чтобы ошибка выполнялась несколько раз. Например, первый раз в функции, а второй раз в блоке, где эта функция вызывается. Рассмотрим пример:

def divide(a: int, b: int) -> int:
    try:
        return a // b
    except ZeroDivisionError:
        print("Unable to divide")
        raise


input = [(2, 1), (10, 5), (3, 0)]
result = []
for numerator, denominator in input:
    try:
        result.append(divide(numerator, denominator))
    except ZeroDivisionError as error:
        result.append(0)
        print(f"Error: {error} for denominator {denominator}")

# Если в этом примере вы не используете рейз, то в список результатов будет записано значение None. Поскольку ошибка была вызвана только один раз внутри функции деления, она не вызывается в цикле.

# Производительность исключений
# Помните, что использование блока try-except должно быть ограничено. Иногда он не несет никакой функциональной нагрузки, но в то же время тормозит работу программы.
#
# Давайте сравним два примера кода:
my_dict = {}

for _ in range(1000):
	try:
		print(my_dict["a"])
	except KeyError:
		pass

# 0.000128 seconds


for _ in range(1000):
	If "a" in my_dict:
		print(my_dict["a"])

# 0.0000498 seconds

# В этом примере блок try-except работает медленнее, чем простая проверка с помощью оператора if.