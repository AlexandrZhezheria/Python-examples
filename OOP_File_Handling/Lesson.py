# Работа с файлами
# Использование файла
# Иногда нам приходится работать с файлами. Например, когда есть необходимость в долговременном хранении информации о выполнении программы. Это особенно полезно, если вы регулярно запускаете свою программу. Нужно фиксировать и логировать, началось и сработало или сработало неправильно и закончилось. Одним из решений проблемы долговременного хранения информации является ее запись в файл. Но, нужно понимать, что если есть возможность записи в файл, то должна быть и возможность чтения этого файла, его редактирования или удаления.
#
# Действия с файлами
# Теперь рассмотрим действия, доступные для работы с файлами в Python.
#
# Режимы открытия
# Перед началом работы с файлом и выполнения над ним действий необходимо его открыть. Вы можете сделать это с помощью встроенного метода open(). В круглых скобках мы сначала пишем путь к файлу, а затем режим, в котором мы хотим открыть файл.
#
# Если вы не укажете режим, он автоматически откроется в режиме tr по умолчанию, что означает чтение в текстовом режиме.
#
# Рассмотрим, какие файловые режимы существуют:
#
# r — читает файл и возвращает ошибку, если файл не существует;
# w — записывает данные в файл и создает новый файл, если он не существует или перезаписывает существующий файл;
# а — добавляет данные в файл и создает файл, если он не существует, или добавляет новую информацию в конец существующего файла;
# x — записывает данные в файл и возвращает ошибку, если файл уже существует (эксклюзивное создание);
# t — используется только для текстовых файлов (текстовый режим — мы видим текст);
# б — используется для нетекстовых файлов, таких как изображения, видео и т. д. (бинарный режим — мы видим 0 и 1);
# + — позволяет работать в режимах чтения и записи одновременно.
# А теперь давайте посмотрим, как это работает. Пусть у нас есть файл «errors.txt», который содержит следующие данные:
# 10:53 12/09/2022 too many requests
# 21:17 13/09/2022 user admin not found
# Мы можем открыть этот файл следующим образом:
file = open("errors.txt")
# В этом примере файл был открыт в режиме tr по умолчанию, так как мы не указали, какой режим нам нужен.
# Теперь откроем этот же файл в режиме чтения:
file = open("errors.txt", "r")
# Обратите внимание: нет никакой разницы между режимами r и tr, так как по умолчанию используется текстовый режим.
#
# Закрытие
# Пока мы только научились открывать файлы, а вот их закрытие — обязательная процедура при работе с файлами.
# Представьте, что вы запустили большой проект, который часто записывает информацию в файл. Далее вы забыли закрыть файл, и программа продолжает работать, даже если вам больше не нужно писать в файл.
# Через некоторое время файл будет заполнен ненужной информацией, и большой объем памяти компьютера будет занят этой информацией, что приведет к системным ошибкам. Чтобы избежать такого сценария, обязательно закрывайте файл после использования.
# Вы можете сделать это с помощью встроенного метода close(). Вот пример того, как это работает:
file = open("errors.txt", "r")
file.close() # Here we closed the file
# Чтение
# Чтобы прочитать весь файл в одну переменную, используйте метод read().
file = open("errors.txt", "r")

print(file.read())
# 10:53 12/09/2022 too many requests
# 21:17 13/09/2022 user admin not found

file.close() # And do not forget to close your file
# Если вы передадите числовой аргумент методу read(), он вернет указанное количество символов из файла:
file = open("errors.txt", "r")
print(file.read(10))    # 10:53 12/0
file.close()
# Чтобы начать чтение не с начала файла, используйте метод seek() и укажите внутри количество необходимых пропускаемых символов:
file = open("errors.txt", "r")

file.seek(10)
print(file.read())
# 9/2022 too many requests
# 21:17 13/09/2022 user admin not found

file.close()
# Чтобы прочитать файл построчно, создайте цикл и используйте метод readline() или readlines(). Метод readline() возвращает строку из файла при вызове, а метод readlines() возвращает все строки в файле в виде списка, где каждый элемент является строкой в файле. Например:
file = open("errors.txt", "r")

print("Readline method working")
print(file.readline())

file.close()
# В консоли вы увидите:
# Readline method working
# 10:53 12/09/2022 too many requests
# И пример метода readlines():
file = open("errors.txt", "r")

line_number = 1		# Variable for seeing the number of a line
print("Readlines method working")
for line in file.readlines():
    print(f"Line number {line_number}")
    print(line)
    line_number += 1

file.close()
# В консоли вы увидите:
# Readlines method working
# Line number 1
# 10:53 12/09/2022 too many requests
# Line number 2
# 21:17 13/09/2022 user admin not found
# Интересная часть этих методов заключается в том, что здесь у нас не будет проблем с памятью — в один момент мы читаем только 1 строку из файла, а не весь файл, как в методе read(). Таким образом, даже если файл огромен, мы все равно можем обработать его чтением построчно (да, это может быть долгий процесс, но все же мы можем).
#
# Другой способ чтения построчно — перебрать его с помощью цикла for без каких-либо дополнительных методов:
file = open("errors.txt", "r")

line_number = 1		# Variable for seeing the number of a line
for line in file:
    print(f"Line number {line_number}")
    print(line)
    line_number += 1

file.close()
# In the console you will see:
# Line number 1
# 10:53 12/09/2022 too many requests
# Line number 2
# 21:17 13/09/2022 user admin not found
# Написание и добавление
# Для записи информации в файл используйте w — режим записи. Открытие файла в режиме записи создает новый файл, если он не существует, или перезаписывает существующий файл. Одним из способов записи информации в файл является встроенный метод write().
#
# Обратите внимание: в качестве аргументов в метод write() можно передавать только строки:
file = open("errors.txt", "w")
file.write("17:00 14/09/2022 value error")

file.close()
# Теперь файл «errors.txt» содержит строку «17:00 14/09/2022 value error». Старая информация из файла была перезаписана новой.
# Чтобы добавить некоторые данные в файл без потери существующей информации, нам нужно открыть файл в режиме a — append. Этот режим создает файл, если он не существует, или добавляет новую информацию в конец существующего файла. Для записи информации в файл также используйте метод write():
file = open("errors.txt", "a")
file.write("17:00 14/09/2022 value error")

file.close()
# Now, if we read the file, in the console we will see:
#
# 10:53 12/09/2022 too many requests
# 21:17 13/09/2022 user admin not found
# 17:00 14/09/2022 value error
# Вы можете увидеть разницу между режимами записи и добавления в этих примерах. В первом примере существующая информация была заменена новой информацией. Во втором примере новая информация была записана после существующей информации в конце файла.
#
# Менеджеры контекста в файлах
# Но что произойдет, если вы забудете закрыть файл после его открытия? Нам лучше не узнавать. Python может предотвратить это. Для этого — используйте контекстные менеджеры.
#
# Менеджеры контекста часто связаны с оператором with. Оборачивая работу с файлом в контекстный менеджер — он автоматически закроет файл при выходе из этой области.
#
# Рассмотрим два похожих примера:
file = open("errors.txt", "r")
# Some actions with file
file.close()

# Как вы можете видеть в этих двух решениях, файл открывается и закрывается. Зато второй чехол занимает меньше места, выглядит изящнее и гарантирует закрытие файла, даже если вы о нем забудете.
#
# Вы всегда должны использовать контекстные менеджеры, потому что, когда возникает ошибка между открытием и закрытием файла, программа завершается, но контекстный менеджер закроет файл, даже если произойдет ошибка.
#
# Например, этот файл будет закрыт:

with open("errors.txt", "w+") as file:
    file.read()
    file.write(1/0)
# Обратите внимание: контекстный менеджер работает не только с файлами. Различные примеры его использования будут рассмотрены далее в других темах.
#
# Основные моменты, которые следует помнить при работе с контекстными менеджерами:
#
# Менеджер контекста всегда содержит два специальных метода: __enter__ и __exit__.
# Метод __enter__ возвращает объект, присвоенный переменной после ключевого слова as. Значение по умолчанию — None, и это необязательно.
# Если в __init__ или __enter__ возникает ошибка, то блок кода никогда не выполняется и __exit__ не вызывается.
# После входа в блок кода всегда вызывается __exit__, даже если в нем возникает исключение.
# Это структура менеджера контекста:
# Solution 2

with open("errors.txt", "r") as file:
   # Some actions with file

   class CustomContextManager():
       def __init__(self):
           pass

       def __enter__(self):
           pass

       def __exit__(self):
           pass

       def __del__(self):
           pass
